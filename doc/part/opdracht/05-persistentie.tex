\chapter{Opdracht 5: Persistentie}
Het Engelse \texttt{to persist} betekent \texttt{volharden} 
en dat is precies wat persistentie inhoudt:
de opslag overleeft het afsluiten van de applicatie.
Het gaat dus langer mee dan het werkgeheugen, bijvoorbeeld 
door de data op te slaan in een bestand, database of web service.

Wij gebruiken hiervoor een erg betrouwbare technologie die
maar liefst een halve eeuw geleden is ontwikkeld! Nog steeds 
is het bij vele grote en kleine technologiebedrijven te vinden: 
een Relational Database Management System (RDBMS).

De database die we gebruiken is PostgreSQL. 
Hiermee kunnen we praten middels SQL:
\textit{Structured Query Language}.

Een relationele database biedt onder meer garanties rondom de 
integriteit bij het wegschrijven en uitlezen van data 
dankzij \textit{transactions}. Ook blijft de data consistent 
wanneer meerdere gebruikers tegelijkertijd met de data werken
dankzij \textit{concurrency control} middels locking.

De details van persistentie en SQL leer je bij de cursus 
Data and Persistency. Wij gebruiken Spring Boot en Hibernate
om het ons wat makkelijker te maken. Maar daarmee moeten we nog 
wel leren werken.

\section{Stap 1: Doorgrond de object-relational impedance mismatch}
In onze cursus staat het objectmodel centraal. Een relationele database 
werkt echter volgens een heel ander idee.

Relationele databases werken, kort gezegd, volgens het volgende conceptuele model:
\begin{enumerate}
    \item Data wordt gestructureerd in \textbf{entiteiten (tabellen)} met \textbf{velden (kolommen)}
    \item Data kan worden ingevuld in \textbf{rijen}: per entiteit worden dan de kolommen ingevuld
    \item Entiteiten zijn identificeerbaar middels een \textbf{identifier (id)}
    \item Tussen entiteiten kunnen \textbf{relaties} bestaan door naar elkaars identifiers te wijzen
\end{enumerate}

Een andere manier hoe relationele databases anders werken dan onze applicatie is dat 
ze gebruik maken van een andere taal. De database maakt immers gebruik van SQL, terwijl 
onze applicatie is geschreven in Java!

Er zit dus een mismatch tussen het objectmodel, 
waarin we een objectboom maken (een spel met allerlei benodigdheden),
en het relationele model, waarin we entiteiten met relaties hebben.
Deze mismatch noem je de \textit{object-relational impedance mismatch}
(\textit{impedantie} betekent `belemmering, bemoeilijking of weerstand').

Om deze mismatch te doorbreken kent een applicatie meestal
\textit{infrastructuur-laag}, 
waarin de omzetting plaatsvindt van Java naar SQL, 
van objectmodel naar relationeel model.

In ons project schrijven we deze laag niet zelf, maar laten we 
een \textit{object-relational mapper (ORM)} het werk doen: 
\textit{Hibernate} via \textit{Spring JPA}.
Wij declareren een \textit{repository} 
(in de \textit{data-laag}), 
een interface voor opslag welke door Spring geïmplementeerd wordt
op basis van de geconfigeerde database. Dat scheelt een boel werk!
Voor de omzetting van domeinobjecten naar entiteiten kunnen 
we annotaties gebruiken om aan te geven welke kolommen we nodig hebben en welke relaties er 
gelegd moeten worden. Dit kunnen we in aparte data-objecten doen, maar
in ons project staan we het toe om onze domein-objecten van annotaties te voorzien.

Het mooie hieraan is dat we in onze service kunnen zeggen:
\texttt{this.repository.save(game)}. Spring regelt de rest op 
basis van onze annotaties. En die annotaties... dat is gelijk 
het moeilijke hieraan! Daarom gaan we daarmee oefenen.

\subsection{Kanttekening: Geen écht lagenmodel}
Hiermee koppelen we wel onze datalaag aan onze domeinlaag. Dit is 
gek in het kader van een gelaagde architectuur: afhankelijkheden lopen daarin 
meestal maar één kant op. Voor dit project staan we het echter toe.
De impact van deze koppeling is namelijk te rechtvaardigen omdat de opslag 
in dienst staat van het domein. Het zijn immers de domeinobjecten die we 
willen opslaan. Willen we onze applicatie meer overeen laten komen met een 
gelaagd systeem, dan zouden we de twee lagen kunnen samenvoegen of een expliciete 
vertaalslag kunnen toevoegen tussen domein- en data-laag. Dat gaat voor deze cursus te ver
en komt terug in de cursus \textbf{Software Architecture}.

\section{Stap 2: Maak een logisch datamodel}
Voordat we verder gaan, is het van belang om op basis van 
ons domein- en objectmodel een logisch datamodel te maken. 
Een logisch datamodel geeft ons een overzicht van hoe onze 
data gestructureerd gaat worden. Het hoeft niet zo te zijn 
dat het in de code exact hetzelfde wordt. Dat geeft ons wat 
ruimte om met de verschillen tussen het objectmodel en het 
relationele model om te gaan.

Een Entity Relationship Diagram (ERD) kan als logisch datamodel dienen.
We nemen entiteiten, kolommen en relaties op, 
maar hoeven de datatypes niet te specificeren.
Voor meer informatie over ERDs, zie de 
\href{https://www.visual-paradigm.com/guide/data-modeling/what-is-entity-relationship-diagram/#erd-data-models-conceptual}{handige uitleg van Visual Paradigm}

Met het ERD willen we de volgende vragen beantwoorden:
\begin{enumerate}
    \item Welke entiteiten hebben we in ons systeem? 
    Denk aan wat, binnen het relationele model, identificeerbaar moet zijn!
    \item Welke kolommen moeten de entiteiten hebben?
    Past het daadwerkelijk in een kolom of is er een extra entiteit nodig?
    \item Welke relaties gelden er tussen die entiteiten?
    Gaat het om een-op-een of een-op-meer?
\end{enumerate}

Gebruik een tool als \textit{diagrams.net}, \textit{software ideas modeler} of \textit{visual paradigm},
sla het ontwerp op en exporteer het als \textit{.png} of \textit{.jpg}. 
Neem dit op in je projectdirectory (bijvoorbeeld onder een mapje \textit{diagrams})
en commit het resultaat, zodat je docent er naar kan kijken en er feedback op kan geven.
Dit hoeft niet in een keer goed te zijn, dus verzand niet teveel in details.

\section{Persistentie in Java}
In ons project werken we met een variant van het populaire Spring-framework:
Spring Boot. Spring Boot maakt gebruik van Spring Data JPA, wat \textit{repositories} toevoegt.
Een repository is een opslagmechanisme voor entiteiten. In Spring Data JPA wordt 
voor relationele databases Hibernate gebruikt, een library die de 
gestandardiseerde Java Persistency API (JPA) implementeert.

Hibernate is een object-relational mapper (ORM). Dit betekent vrij letterlijk
dat het de mapping (of: vertaling) verzorgt tussen het objectmodel 
en het relationele model!
Deze mapping kunnen we natuurlijk met de hand doen 
door SQL-queries te schrijven voor elk object, maar Hibernate geeft ons de optie 
om dit met minder woorden te doen via XML of annotaties. In Java zijn 
annotaties tegenwoordig de meestgebruikte aanpak.
Een ORM heeft als doel om de 
\textit{object-relational impedence mismatch} te verkleinen!

\subsection{Data entities}
Een \textit{data entity} (of kortweg: \textit{entity}) is 
een eenvoudige manier om persistentie van objecten te realiseren. 
Het kan een simpel object zijn met alleen velden en wat getters
of een object zijn met meer complex gedrag. 

Een eenvoudig voorbeeld is te vinden in de Chips-entity.
Hier zijn alleen geen relaties in opgenomen:

\begin{minted}{java}
@Entity
public class Chips {
    @Id
    @GeneratedValue
    private Long id;

    private String username;

    private Long amount;

    @CreationTimestamp
    @Temporal(TemporalType.TIMESTAMP)
    private Date creationDate;

    @UpdateTimestamp
    @Temporal(TemporalType.TIMESTAMP)
    private Date lastUpdate;

    public Chips() {
    }

    // Methods...
}
\end{minted}

\subsection{Repositories}
Een \textit{repository} is een \textit{DAO (data access object)} 
dat zich als verzameling gedraagt. 
Een DAO is een specifieke vorm van een \textit{gateway}: 
een interface naar buiten toe dat verschillende implementaties kan hebben.
Hierover later meer.
In ons project wordt de implementatie verzorgt door Spring zelf, op basis van wat 
wij hebben geconfigureerd in de \textit{application.properties} en de \textit{entities}.

\subsection{Overzicht Spring Data JPA en Hibernate}
Het is zeer de moeite waard om de documentatie van 
\href{https://docs.jboss.org/hibernate/stable/annotations/reference/en/html_single/#entity-overview}{Hibernate (entity annotations)}
en 
\href{https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories}{Spring Data JPA (repositories)}
door te nemen en als referentie te gebruiken (tip: doorzoek digitale bronnen met \texttt{CTRL + F}!). 
In deze bronnen zijn ook een aantal voorbeelden opgenomen.

\section{Stap 3: Annoteer de hoofdentiteit}
Als het goed is hebben we één hoofdobject waar alle domeinacties
op uitgevoerd worden.

Om een entity te maken met Hibernate moet 
je de betreffende klasse voorzien van de 
annotatie \texttt{@Entity}. Een hele hoop dingen 
hoeven we niet aan te geven, zoals tabelnaam en kolomnamen.
Deze kunnen we wel wijzigen, maar Hibernate pakt de naam 
van de klasse en de velden. Het kan nuttig zijn om dit aan 
te geven om wijzigingen over tijd makkelijker te maken door
de tabelstructuur en de klassestructuur los te koppelen.

Omdat entiteiten
identificeerbaar zijn, moeten we een veld 
aanmerken als identifier. Dit doen we door de annotatie 
\texttt{@Id} boven een veld te zetten. Heeft een entity
nog geen id-veld? Dan kunnen we er een aanmaken. Het is 
een aardig idee om hiervoor een Integer of zelfs een Long 
te gebruiken. Deze kan je door de database laten genereren 
door tussen het veld en de \texttt{@Id}-annotatie 
de annotatie \texttt{@GeneratedValue} op te nemen. 
Bij de meeste databases zal er dan een incrementele, 
sequentiële identifier (een getal dat automatisch oploopt) 
worden gebruikt. Een nadeel hiervan is dat je pas ná het opslaan 
van een nieuwe entiteit in de database weet van zijn identifier. 
Dit kan in sommige situaties problematisch of inefficiënt zijn.
In dat soort gevallen kan je globally unique identifiers (GUIDs)
of universally unique identifiers (UUIDs) gebruiken. Deze kunnen 
in je code worden gegenereerd en zijn ontworpen om zelden collissions
te hebben.

Een aanvullende eis van Hibernate voor entiteiten is
dat de klasse ofwel géén constructor heeft 
ofwel een lege constructor als er al een constructor bestaat. 
Hibernate neemt namelijk een leeg 
object als uitgangspunt en vult dynamisch de velden op basis van 
verdere mapping-annotaties.

Van kolommen waarvan Hibernate niet weet hoe ze in SQL-termen moeten 
worden omgezet, moeten we aangeven hoe Hibernate deze mapping moet 
verzorgen.

Ten slotte moeten relaties naar andere klassen die als
\texttt{@Entity} zijn aangemerkt worden gespecifeerd:
betreft het bijvoorbeeld een \texttt{@OneToMany} (zoals bij lijsten) of een
\texttt{@OneToOne}. Daarbij moeten we ook aangeven in hoeverre 
wijzigingen in de ene entiteit effect hebben op de andere.
Meestal willen we dat de wijzigingen in de hoofdentiteit 
terechtkomen in entiteiten waarnaar verwezen wordt. 
Dit doe je door de cascadetype te specificeren in je 
annotatie, bijvoorbeeld: \texttt{@OneToMany(cascade=CascadeType.ALL)}. 
Hiermee voorkom je de veelvoorkomende foutmelding: 
``object references an unsaved transient instance 
- save the transient instance before flushing''

\subsubsection{De Game-entiteit}
Laten we wederom de \texttt{Game}-klasse nemen. Allereerst moeten 
we zorgen dat de klasse identificeerbaar is. We moeten dus een 
veld id (type \textit{Long}) toevoegen als we dat nog niet hebben gedaan.
Dit veld moeten we als \texttt{@Id} en \texttt{@GeneratedValue} markeren.

Vervolgens moeten we per veld kijken of dit een kolom op zichzelf kan zijn 
of een mapping vereist naar een andere entiteit toe. In het eerder besproken model 
wordt een spelpotje altijd gespeeld met één Deck. Er is dus sprake van een 
\texttt{@OneToMany} relatie naar die Deck toe.

\section{Stap 4: Annoteer de overige entiteiten}
Dit moeten we doen voor alle entiteiten, bijvoorbeeld voor de 
eerder besproken Deck-entiteit. 

Als snel kom je problemen tegen. Niet alles is makkelijk te vertalen naar 
tabellen en kolommen. Het is de \textit{object-relational impedence mismatch}!

Denk bijvoorbeeld aan hoe je een Deck met Cards opslaat.
We kunnen per speelkaart 
een rij opnemen in een "cards" tabel (52 kaarten) 
met elk hun unieke id (0 t/m 51), maar het is misschien logischer 
om een kaart niet te modelleren als entiteit, maar als samengestelde waarde.
Een harten aas kan immers in meerdere spelpotjes voorkomen!
Hoe gaan we daarmee om? En wat doen we met andere zaken die 
we als enum hebben gemodelleerd, zoals misschien de spelstatus?
Zie hiervoor stap 5.

\section{Stap 5: Zorg voor conversies van enums en samengestelde waarden}
Enums worden standaard omgezet naar integer representaties
op basis van de volgorde van declareren in de enum-klasse.
Als je de volgorde in je code dus aanpast, krijg je problemen 
in je datamodel!

Daarom kan het handig zijn om de enum om te zetten naar een 
text-representatie in het relationele model. Dit doet je 
door het betreffende veld aan te merken als \texttt{@Enumerated(EnumType.STRING)}. 

Het risico is dan weer wel dat de 
mapping kan breken wanneer je een naam aanpast!

Sommige objecten zijn niet echt entiteiten of enums, maar weer 
groeperingen van waardes. Het is niet heel zinvol om hier 
het relationele model op los te laten. Deze klassen zou je 
eerder kunnen zien als waarden die weliswaar in losse velden 
in een aparte klasse zitten in het objectmodel, maar in het 
relationele model prima in één kolom kunnen leven.
Denk bijvoorbeeld aan een kaart of lijst van kaarten.

Bij platte data kan je dit oplossen door een 
\texttt{@Embeddable} object te maken (in plaats van een 
\texttt{@Entity}) en dit object in een  
veld op te nemen dat in de entiteit als \text{@Embedded}.
Voor een lijst van kaarten werkt dit niet.

Een goede, maar vrij geavanceerde oplossing is het aanmaken 
van een \textit{JPA Attribute Converter}. Dit is een aparte 
klasse die je in de datalaag kan aanmaken en als \texttt{@Converter}
moet worden aangemerkt. Bijvoorbeeld een \texttt{CardsConverter}.
Deze klasse moet JPA's \texttt{AttributeConverter<T, U>}
interface implementeren: 

\begin{minted}{java}
public class CardsConverter implements AttributeConverter<List<Card>, String>
    @Override
    public String convertToDatabaseColumn(List<Card> list) {
        // Convert list of cards to a single string 
        // (i.e. based on rank and suit)
        //
        // For instance: HEARTS, SPADES, CLUBS, DIAMONDS -> H, S, C, D
        // and: ACE, 2, 3, ... -> A, 2, 3
        // Then, a list of cards could be formatted as: AH, 5C, 2D, meaning: Ace of Hearts, 5 of Clubs and 2 of Diamonds
    }

    @Override
    public List<Card> convertToEntityAttribute(String joined) {
        // Convert a single string to list of cards
        // (i.e. by splitting the string and reading out the rank and suit from the string)
    }
}
\end{minted}

Als het allemaal niet wil lukken, dan zou je een deel kunnen omzetten naar een \texttt{@Lob}:
een large object binary. Dan wordt het object opgeslagen en uitgelezen 
in binaire vorm. Dit brengt wel een groot risico met zich mee qua onderhoudbaarheid
wanneer de vorm van het object wijzigt in je Java-code!
Probeer dit dus alleen te doen bij objecten die klein en/of vormvast zijn!

Je hebt zelf de keuze om een van deze oplossingen te kiezen.

\section{Stap 6: Maak een repository voor de hoofdentiteit}
Het maken van een Repository is vrij eenvoudig: we \textit{extenden} een bestaande 
generieke repository interface. Spring biedt een aantal verschillende aan, elk met 
weer een stukje extra functionaliteit. De meest basale is \texttt{Repository<T, ID>},
deze geeft aan dat het om een repository gaat voor een bepaalde entiteit die benaderbaar is 
met een bepaalde id. De benodigde methodes moet je zelf toevoegen. Dat hoeft bijvoorbeeld niet 
in het subtype ervan, \texttt{CrudRepository<T,ID>}, welke generieke acties aanbiedt voor
Create, Read, Update Delete (CRUD). De meest specifieke repository is de \texttt{JpaRepository<T,ID>},
welke een uitbreiding is van \texttt{CrudRepository<T,ID>} en de \texttt{PagingAndSortingRepository<T,ID}.
Het biedt extra functionaliteit voor projecten die met JPA kunnen werken
en geeft de mogelijkheid om flexibel met verzamelingen te werken.

Een repository is een soort \textit{gateway}: een abstractie vanuit de component naar de buitenwereld toe.
In dit geval betreft het een \textbf{infrastructuurabstractie}, namelijk een toegangspoortje naar een database.
Wij hoeven maar één repository te maken. Maak een de package \textit{nl.hu.bep2.blackjack.data} aan.
Maak hierin de interface aan \textit{GameRepository}. Denk aan de hotkeys!
We moeten aan Spring duidelijk maken dat het gaat om een subtype van \texttt{JpaRepository<T, ID>},
waarbij we het typeargument \texttt{T} invullen met \texttt{Game} en de identifier invullen met \texttt{Long}.
Met andere woorden: we willen een repository voor games die identificeerbaar zijn met een long.
Spring kan dan op basis van de entity definities een implementatie genereren en wij kunnen zelfs 
een soort queries definiëren in onze interface. 
Dit hoeven we voorhet project waarschijnlijk niet te doen.
We laden een object in, voeren er operaties op uit en slaan het weer op. 
We zouden dus net zo goed een \texttt{CrudRepository<T, ID>}
kunnen maken. 

Hoe dan ook, het zal de volgende vorm hebben 
(dit kan je overnemen):
\begin{minted}{java}
package nl.hu.bep2.casino.blackjack.data;

import nl.hu.bep2.casino.blackjack.domain.Game;
import org.springframework.data.jpa.repository.JpaRepository;

public interface GameRepository extends JpaRepository<Game, Long> {}
\end{minted}

Merk op dat de klasse leeg kan blijven omdat we extenden van Spring's repositories.

\section{Stap 7: Verbeter de applicatieservices}
Zorg dat onze applicatieservice bij onze repository kan door 
deze als veld op nemen. Spring zal de dependency injection via 
auto-wiring verzorgen.

Verder is het verstandig om de \texttt{@Transactional} annotatie 
op te nemen boven de klasse. Dit zorgt ervoor dat alle acties 
die door de service worden uitgevoerd in één databasetransactie 
worden uitgevoerd. Als er ergens in het proces wat misgaat, worden 
de alle database-operaties binnen die actie teruggedraaid.

Je zal waarschijnlijk op het volgende uitkomen:
\begin{minted}{java}
@Service
@Transactional
public class BlackjackService {
    private GameRepository gameRepository;
    private ChipsService chipsService;

    public BlackjackService(GameRepository gameRepository, ChipsService chipsService) {
        this.gameRepository = gameRepository;
        this.chipsService = chipsService;
    }
    
    // Methods for use cases...
}
\end{minted}

Verbeter vervolgens alle use case-methodes om gebruik te maken voor het 
opslaan en uitlezen van de Game. De start game methode kan natuurlijk nog geen 
spel ophalen.

Heb je het met meerdere centrale objecten opgelost, 
dan zal je meerdere repositories moeten 
aanmaken, injecteren en aanroepen.